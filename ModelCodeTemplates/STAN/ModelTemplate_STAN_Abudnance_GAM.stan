// N-Mixture GAM - STAN Code Template 

// Stan model code generated by package mvgam
data {
  int<lower=0> total_obs; // total number of observations
  int<lower=0> n; // number of timepoints per series
  int<lower=0> n_sp_trend; // number of trend smoothing parameters
  int<lower=0> n_lv; // number of dynamic factors
  int<lower=0> n_series; // number of series
  matrix[n_series, n_lv] Z; // matrix mapping series to latent states
  int<lower=0> num_basis; // total number of basis coefficients
  int<lower=0> num_basis_trend; // number of trend basis coefficients
  vector[num_basis_trend] zero_trend; // prior locations for trend basis coefficients
  matrix[total_obs, num_basis] X; // mgcv GAM design matrix
  matrix[n * n_lv, num_basis_trend] X_trend; // trend model design matrix
  array[n, n_series] int<lower=0> ytimes;  // time-ordered matrix (which col in X belongs to each [time, series] observation?)
  array[n, n_lv] int ytimes_trend;
  int<lower=0> n_nonmissing; // number of nonmissing observations
  array[total_obs] int<lower=0> cap; // upper limits of latent abundances
  array[total_obs] int ytimes_array; // sorted ytimes
  array[n, n_series] int<lower=0> ytimes_pred; // time-ordered matrix for prediction
  int<lower=0> K_groups; // number of unique replicated observations
  int<lower=0> K_reps; // maximum number of replicate observations
  array[K_groups] int<lower=0> K_starts; // col of K_inds where each group starts
  array[K_groups] int<lower=0> K_stops; // col of K_inds where each group ends
  array[K_groups, K_reps] int<lower=0> K_inds; // indices of replicated observations
  matrix[4,8] S_trend1; // mgcv smooth penalty matrix S_trend1
  array[total_obs] int<lower=0> flat_ys; // flattened observations
}
transformed data {
  matrix[total_obs, num_basis] X_ordered = X[ytimes_array,  : ];
  array[K_groups] int<lower=0> Y_max;
  array[K_groups] int<lower=0> N_max;
  for ( k in 1 : K_groups ) {
    Y_max[k] = max(flat_ys[K_inds[k, K_starts[k] : K_stops[k]]]);
    N_max[k] = max(cap[K_inds[k, K_starts[k] : K_stops[k]]]);
  }
}
parameters {
  // raw basis coefficients
  vector[num_basis] b_raw;
  vector[num_basis_trend] b_raw_trend;
  // smoothing parameters
  vector<lower=0>[n_sp_trend] lambda_trend;
}
transformed parameters {
  // detection probability
  vector[total_obs] p;
  // latent states
  matrix[n, n_lv] LV;
  // latent states and loading matrix
  vector[n * n_lv] trend_mus;
  matrix[n, n_series] trend;
  // basis coefficients
  vector[num_basis] b;
  vector[num_basis_trend] b_trend;
  // observation model basis coefficients
  b[1:num_basis] = b_raw[1:num_basis];
  // process model basis coefficients
  b_trend[1:num_basis_trend] = b_raw_trend[1:num_basis_trend];
  // detection probability
  p = X_ordered * b;
  // latent process linear predictors
  trend_mus = X_trend * b_trend;
  for(j in 1:n_lv){
    LV[1:n, j] = trend_mus[ytimes_trend[1:n, j]];
  }
  // derived latent states
  for (i in 1:n){
    for (s in 1:n_series){
      trend[i, s] = dot_product(Z[s,], LV[i,]);
    }
  }
}
model {
  // prior for (Intercept)...
  b_raw[1] ~ std_normal();
  // dynamic process models
  // prior for (Intercept)_trend...
  b_raw_trend[1] ~ normal(1, 1.5);
  // prior for s(covariate)_trend...
  b_raw_trend[2:5] ~ multi_normal_prec(zero_trend[2:5],S_trend1[1:4,1:4] * lambda_trend[1] + S_trend1[1:4,5:8] * lambda_trend[2]);
  lambda_trend ~ normal(5, 30);
  {
    // likelihood functions
    array[total_obs] real flat_trends;
    array[total_obs] real flat_ps;
    flat_trends = (to_array_1d(trend));
    flat_ps = to_array_1d(p);
    // loop over replicate sampling window (each site*time*species combination)
    for (k in 1 : K_groups) {
      // all log_lambdas are identical because they represent site*time
      // covariates; so just use the first measurement
      real log_lambda = flat_trends[K_inds[k, 1]];
      // logit-scale detection probilities for the replicate observations
      vector[size(K_inds[k, K_starts[k] : K_stops[k]])] logit_p = to_vector(flat_ps[K_inds[k, K_starts[k] : K_stops[k]]]);
      // K values and observed counts for these replicates
      int K_max = N_max[k];
      int K_min = Y_max[k];
      array[size(K_inds[k, K_starts[k] : K_stops[k]])] int N_obs = flat_ys[K_inds[k, K_starts[k] : K_stops[k]]];
      int possible_N = K_max - K_min;
      // marginalize over possible latent counts analytically
      real ff = exp(log_lambda) * prod(1 - inv_logit(logit_p));
      real prob_n = 1;
      for (i in 1 : possible_N){
        real N = K_max - i + 1;
        real k_obs = 1;
        for (j in 1 : size(N_obs)){
          k_obs *= N / (N - N_obs[j]);
        }
        prob_n = 1 + prob_n * ff * k_obs / N;
      }
      // add log(pr_n) to prob(K_min)
      target += poisson_log_lpmf(K_min | log_lambda) +
        binomial_logit_lpmf(N_obs | K_min, logit_p) +
        log(prob_n);
    }
  }
}
generated quantities {
  vector[n_lv] penalty = rep_vector(1e12, n_lv);
  vector[total_obs] detprob = inv_logit(p);
  vector[n_sp_trend] rho_trend = log(lambda_trend);
}